# - calculates average school data, generating ruby code
#   average_school_data.rb into the Results directory
# - which then needs to be copied into the
#   lib/dashboard/charting_and_reports/virtual_schools directory

require 'require_all'
require_relative '../../lib/dashboard.rb'
require_rel '../../test_support'

module Logging
  @logger = Logger.new('log/benchmark exemplar school generation ' + Time.now.strftime('%H %M') + '.log')
  logger.level = :debug
end

class CalculateAverageSchool
  SCHOOL_TYPES = %i[primary secondary special]

  def initialize(schools)
    @schools = schools
  end

  def save_average_school_data_to_ruby_file(fuel_data, benchmark_type_config)
    dir = TestDirectory.instance.results_directory('AverageSchool')
    filename = File.join(dir, 'average_school_data.rb')

    puts "Writing to #{filename}"

    File.open(filename, 'w') do |f|
      f.puts '# code auto generated by script\modelling\generate_average_school.rb'
      f.puts "# Last generated #{Time.now.to_s}"
      f.puts 'class AverageSchoolData'
      save_benchmark_type_config_to_csv(f, benchmark_type_config)
      f.puts '  def raw_data'
      f.puts '    {'
      fuel_data.each do |fuel_type, type_data|
        f.puts "     #{fuel_type}: {"
        type_data.each do |benchmark_type, data|
          f.puts "       #{benchmark_type}: {"
          data.each do |school_type, daytype_data|
            f.puts "        #{school_type}: {"
            f.puts "          samples: #{@school_type_samples[school_type][:electricity]},"
            daytype_data.each do |daytype, months_data|
              f.puts "          #{daytype}: {"
              months_data.sort.each do |month_or_holiday, amr_x48|
                metric = fuel_type == :electricity ? 'kWh/pupil' : "kWh/floor area normalised to #{BenchmarkMetrics::ANNUAL_AVERAGE_DEGREE_DAYS} degree days"
                if month_or_holiday.is_a?(Integer)
                  f.puts "            #{month_or_holiday} => [ # average 48x intraday #{metric} readings for #{Date::MONTHNAMES[month_or_holiday]}"
                else
                  f.puts "            #{month_or_holiday}:   [ # average 48x intraday #{metric} readings for #{month_or_holiday.to_s.humanize}"
                end
                save_amr_data_x48(f, amr_x48)
                f.puts '                  ],'
              end
              f.puts '          },'
            end
            f.puts '        },'
          end
          f.puts '       },'
        end
        f.puts '     },'
      end
      f.puts '    }'
      f.puts '  end'
      f.puts 'end'
    end
  end



  def save_benchmark_type_config_to_csv(f, benchmark_type_config)
    f.puts '  def benchmark_calculation_config'
    f.puts '    {'
    benchmark_type_config.each do |benchmark_type, sample_range|
      f.puts "      #{benchmark_type}: #{sample_range.first}..#{sample_range.last},"
    end
    f.puts '    }'
    f.puts '  end'
  end

  def save_average_school_data_to_csv(fuel_data)
    dir = TestDirectory.instance.results_directory('AverageSchool')
    filename = File.join(dir, 'average_school_data.csv')

    CSV.open(filename, 'w') do |csv|
      fuel_data.each do |fuel_type, type_data|
        type_data.each do |benchmark_type, data|
          data.each do |school_type, daytype_data|
            daytype_data.each do |daytype, months_data|
              months_data.sort.each do |month, amr_x48|
                csv << [fuel_type, benchmark_type, school_type, daytype, month, amr_x48.values].flatten
              end
            end
          end
        end
      end
    end
  end

  def save_amr_data_x48(f, amr_x48, indent = '                  ')
    formatted_amr = amr_x48.values.map { |kwh| sprintf('%0.6f', kwh) }
    formatted_amr.each_slice(8) do |four_hours|
      f.puts "#{indent} #{four_hours.join(',')},"
    end
  end

  def calculate_average_school(type: :benchmark, rank_range: 0.2..0.4, fuel_type: :electricity)
    school_averages = calculate_school_averages(fuel_type, type)
    by_school_type = group_by_school_types(school_averages)
    average_by_type_within_rank_range(by_school_type, rank_range)
  end

  def calculate_school_averages(fuel_type, type)
    @school_type_samples ||= Hash.new {|hash, school_type| hash[school_type] = Hash.new{|h, fuel_type| h[fuel_type] = 0 }}

    @schools.map do |school|
      school_type = school.school_type.to_sym
      next unless SCHOOL_TYPES.include?(school_type)

      meter = school.aggregate_meter(fuel_type)

      next if meter.nil? || meter.amr_data.days < 50

      next if fuel_type == :gas && meter.amr_data.days < 350 # degreeday adjustment wont work otherwise

      # only do stats on one benchmark type, as count should be same for the other e.g. :exemplar
      @school_type_samples[school_type][fuel_type] += 1 if type == :benchmark

      end_date = meter.amr_data.end_date
      start_date = [end_date - 365, meter.amr_data.start_date].max
      {
        school_name:  school.name,
        school_type:  school_type,
        monthly_data: calculate_monthly_average_profiles(school, meter, start_date, end_date)
      }
    end.compact
  end

  private

  def schools_with_enough_data(schools, fuel_type)
    schools.select do |school|
      !school.aggregate_meter(fuel_type).nil? && school.aggregated_electricity_meters.amr_data.days > 50
    end
  end

  def group_by_school_types(school_averages)
    by_type = {}

    school_averages.each do |school_data|
      by_type[school_data[:school_type]] ||= []
      by_type[school_data[:school_type]].push(school_data)
    end

    by_type
  end

  def average_by_type_within_rank_range(by_school_type, rank_range)
    data_by_type_then_month_then_half_hour = group_by_type_then_month_then_half_hour(by_school_type)

    data = Hash.new { |hash, key| hash[key] = Hash.new(&hash.default_proc) }

    data_by_type_then_month_then_half_hour.each do |school_type, data_type_data|
      data_type_data.each do |daytype, months_data|
        months_data.each do |month, half_hour_data|
          half_hour_data.each do |half_hour, hh_kwh_xN|
            sample_range = index_range_from_rank_range(hh_kwh_xN.length, rank_range)

            to_average = hh_kwh_xN.sort[sample_range]

            next if to_average.nil? || to_average.length < 1

            avg = to_average.sum / to_average.length

            data[school_type][daytype][month][half_hour] = avg
          end
        end
      end
    end

    data
  end

  def index_range_from_rank_range(length, rank_range)
    index_range_low  = (length * rank_range.first).to_i
    index_range_high = (length * rank_range.last).to_i
    index_range_low..index_range_high
  end

  def group_by_type_then_month_then_half_hour(by_school_type)
    data = group_by_type_then_month(by_school_type)

    data_by_month_half_hour = Hash.new { |hash, key| hash[key] = Hash.new(&hash.default_proc) }

    data.each do |school_type, data_type_data|
      data_type_data.each do |daytype, schools_data|
        schools_data.each do |school_data|
          months_or_holidays = daytype == :holiday ? Holidays::MAIN_HOLIDAY_TYPES : 1..12
          months_or_holidays.each do |month|
            (0..47).each do |half_hour|
              amr_x48 = school_data.dig(:amr_xN_x48, month)
              unless amr_x48.nil?
                data_by_month_half_hour[school_type][daytype][month][half_hour] = [] unless data_by_month_half_hour[school_type][daytype][month][half_hour].is_a?(Array)
                data_by_month_half_hour[school_type][daytype][month][half_hour].push(amr_x48[half_hour])
              end
            end
          end
        end
      end
    end

    data_by_month_half_hour
  end

  def group_by_type_then_month(by_school_type)
    data = {}

    by_school_type.each do |school_type, schools|
      data[school_type] ||= {}
      schools.each do |school|
        school[:monthly_data].each do |month, amr_x48|
          data[school_type][month] ||= []
          data[school_type][month].push({school_name: school[:school_name], amr_xN_x48: amr_x48})
        end
      end
    end

    data
  end

  def calculate_monthly_average_profiles(school, meter, start_date, end_date)
    collated_data = collate_data(school, meter, start_date, end_date)
    factor = normalising_factor(school, meter, start_date, end_date)
    average_data(collated_data, factor)
  end

  def normalising_factor(school, meter, start_date, end_date)
    if meter.fuel_type == :electricity
      1.0 / school.number_of_pupils(start_date, end_date)
    else
      degree_days_to_average_factor(school, start_date, end_date) / school.floor_area(start_date, end_date)
    end
  end

  def degree_days_to_average_factor(school, start_date, end_date)
    avg_degree_days = BenchmarkMetrics::ANNUAL_AVERAGE_DEGREE_DAYS

    school_degree_days = school.temperatures.degree_days_in_date_range(start_date, end_date)

    # very crude for as really need to scale monthly degree days
    # versus precalculated national average for each month
    # school.aggregated_heat_meters.heating_model.heating_on?(date)

    
    # if a school is colder than average i.e. > school_degree_days reduce its consumption for average
    avg_degree_days / school_degree_days
  end

  def collate_data(school, meter, start_date, end_date)
    data = { schoolday: {}, holiday: {}, weekend: {} }

    (start_date..end_date).each do |date|
      daytype = school.holidays.day_type(date)
      month = month_or_holiday(school, date)
      data[daytype][month] ||= []
      data[daytype][month].push(meter.amr_data.days_kwh_x48(date))
    end

    data
  end

  def month_or_holiday(school, date)
    if school.holidays.day_type(date) == :holiday
      holiday_type = Holidays.holiday_type(date)
      holiday_type = AverageSchoolCalculator.remap_low_sample_holiday(holiday_type)
      raise "Unknown holiday type for #{school.name} #{date}" if holiday_type.nil?
      holiday_type
    else
      date.month
    end
  end

  def average_data(collated_data, factor)
    data = { schoolday: {}, holiday: {}, weekend: {} }

    collated_data.each do |daytype, months|
      months.each do |month, amr_data_x48_x30|
        data[daytype][month] = AMRData.fast_multiply_x48_x_scalar(AMRData.fast_average_multiple_x48(amr_data_x48_x30), factor)
      end
    end

    data
  end
end

def load_schools(pattern_match) 
  source_db = :unvalidated_meter_data

  results = {}

  school_names = SchoolFactory.instance.school_file_list(source_db, pattern_match)

  schools = school_names.map do |school_name|
    school = SchoolFactory.instance.load_school(source_db, school_name, cache: true)
  rescue => e
    puts e.message
    puts e.backtrace
  end
end

def test_calculate_average_school
  source_db = :unvalidated_meter_data
  school_names = SchoolFactory.instance.school_file_list(source_db, ['trini*'])
  school = SchoolFactory.instance.load_school(source_db, school_names[0], cache: true)
  avg = AverageSchoolCalculator.new(school)
  amr_data = avg.benchmark_amr_data
  puts "#{amr_data.start_date} #{amr_data.end_date} #{amr_data.total}"
end

if false
  test_calculate_average_school

  exit
else
  best_test = ['king-james*','all-saints-p*', 'fairview-school*'] # one of each type of school allows test and copying of .rb file

  school_name_pattern_match = ['*']

  benchmark_type_config = [[:average, 0.4..0.6], [:benchmark, 0.2..0.4], [:exemplar, 0.1..0.25]]

  data = Hash.new { |hash, key| hash[key] = Hash.new(&hash.default_proc) }

  schools = load_schools(school_name_pattern_match)

  calc = CalculateAverageSchool.new(schools)

  %i[electricity gas].each do |fuel_type|
    benchmark_type_config.each do |(type, range_range)|
      data[fuel_type][type] = calc.calculate_average_school(type: type, rank_range: range_range,  fuel_type: fuel_type)
    end
  end

  calc.save_average_school_data_to_ruby_file(data, benchmark_type_config)
  calc.save_average_school_data_to_csv(data)
end
